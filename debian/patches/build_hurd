Description: Fix build problems on hurd-i386
 This patch allows Open MPI to build on Debian GNU/HURD.
Author: Pino Toscano <pino@kde.org>
Forwarded: yes
Last-Update: 2010-07-20

--- a/ompi/runtime/ompi_mpi_abort.c
+++ b/ompi/runtime/ompi_mpi_abort.c
@@ -53,10 +53,11 @@
                bool kill_remote_of_intercomm)
 {
     int count = 0, i;
-    char *msg, *host, hostname[MAXHOSTNAMELEN];
+    char *msg, *host = NULL;
     pid_t pid = 0;
     orte_process_name_t *abort_procs;
     orte_std_cntr_t nabort_procs;
+    bool free_host = false;
 
     /* Protection for recursive invocation */
     if (have_been_invoked) {
@@ -70,8 +71,12 @@
     if (orte_initialized) {
         host = orte_process_info.nodename;
     } else {
-        gethostname(hostname, sizeof(hostname));
-        host = hostname;
+        size_t host_length = 128;
+        do {
+            host_length *= 2;
+            host = realloc(host, host_length);
+        } while ((gethostname(host, host_length) == -1) && (errno == ENAMETOOLONG));
+        free_host = true;
     }
     pid = getpid();
 
--- a/ompi/runtime/ompi_mpi_finalize.c
+++ b/ompi/runtime/ompi_mpi_finalize.c
@@ -101,13 +101,18 @@
         /* Note that if we're already finalized, we cannot raise an
            MPI exception.  The best that we can do is write something
            to stderr. */
-        char hostname[MAXHOSTNAMELEN];
+        char *hostname = NULL;
+        size_t hostname_length = 128;
         pid_t pid = getpid();
-        gethostname(hostname, sizeof(hostname));
+        do {
+            hostname_length *= 2;
+            hostname = realloc(hostname, hostname_length);
+        } while ((gethostname(hostname, hostname_length) == -1) && (errno == ENAMETOOLONG));
 
         orte_show_help("help-mpi-runtime.txt",
                        "mpi_finalize:invoked_multiple_times",
                        true, hostname, pid);
+        free(hostname);
         return MPI_ERR_OTHER;
     }
 
--- a/opal/mca/base/mca_base_component_find.c
+++ b/opal/mca/base/mca_base_component_find.c
@@ -208,11 +208,16 @@
         }
 
         if (opal_list_get_end(found_components) == item) {
-            char h[MAXHOSTNAMELEN];
-            gethostname(h, sizeof(h));
+            char *h = NULL;
+            size_t h_length = 128;
+            do {
+                h_length *= 2;
+                h = realloc(h, h_length);
+            } while ((gethostname(h, h_length) == -1) && (errno == ENAMETOOLONG));
             opal_show_help("help-mca-base.txt", 
                            "find-available:not-valid", true,
                            h, type, requested_component_names[i]);
+            free(h);
             return OPAL_ERR_NOT_FOUND;
         }
     }
--- a/opal/mca/base/mca_base_param.c
+++ b/opal/mca/base/mca_base_param.c
@@ -186,8 +186,14 @@
     home = (char*)opal_home_directory();
     
     if(NULL == cwd) {
+#if !defined(MAXPATHLEN) && defined(__GLIBC__)
+        cwd = get_current_dir_name();
+        if( NULL == cwd)
+#else
         cwd = (char *) malloc(sizeof(char) * MAXPATHLEN);
-        if( NULL == (cwd = getcwd(cwd, MAXPATHLEN) )) {
+        if( NULL == (cwd = getcwd(cwd, MAXPATHLEN) ))
+#endif
+        {
             opal_output(0, "Error: Unable to get the current working directory\n");
             cwd = strdup(".");
         }
--- a/opal/util/stacktrace.c
+++ b/opal/util/stacktrace.c
@@ -444,8 +444,12 @@
     mca_base_param_lookup_string (param, &string_value);
 
     memset(&act, 0, sizeof(act));
+#ifdef SA_SIGINFO
     act.sa_sigaction = show_stackframe;
     act.sa_flags = SA_SIGINFO;
+#else
+    act.sa_handler = show_stackframe_handler;
+#endif
 #ifdef SA_ONESHOT
     act.sa_flags |= SA_ONESHOT;
 #else
--- a/orte/mca/odls/base/odls_base_default_fns.c
+++ b/orte/mca/odls/base/odls_base_default_fns.c
@@ -1338,8 +1338,13 @@
     orte_local_rank_t local_rank;
     orte_node_rank_t node_rank;
     char *pathenv = NULL, *mpiexec_pathenv = NULL;
+#if !defined(MAXPATHLEN) && defined(__GLIBC__)
+    char *basedir=NULL;
+    char *dir=NULL;
+#else
     char basedir[MAXPATHLEN];
     char dir[MAXPATHLEN];
+#endif
     char **argvptr;
     char *full_search;
     char **argvsav=NULL;
@@ -1593,7 +1598,11 @@
          * again not match getcwd! This is beyond our control - we are only
          * ensuring they start out matching.
          */
+#if !defined(MAXPATHLEN) && defined(__GLIBC__)
+        dir = get_current_dir_name();
+#else
         getcwd(dir, sizeof(dir));
+#endif
         opal_setenv("PWD", dir, true, &app->env);
         
         /* Search for the OMPI_exec_path and PATH settings in the environment. */
@@ -2090,6 +2099,10 @@
  GETOUT:
     opal_condition_signal(&orte_odls_globals.cond);
     OPAL_THREAD_UNLOCK(&orte_odls_globals.mutex);
+#if !defined(MAXPATHLEN) && defined(__GLIBC__)
+    free(basedir);
+    free(dir);
+#endif
     return rc;
 }
 
--- a/orte/orted/orted_main.c
+++ b/orte/orted/orted_main.c
@@ -227,7 +227,7 @@
     int ret = 0;
     int fd;
     opal_cmd_line_t *cmd_line = NULL;
-    char log_file[PATH_MAX];
+    char *log_file = NULL;
     char *jobidstring;
     char *rml_uri;
     int i;
@@ -489,6 +489,7 @@
                                 orte_process_info.top_session_dir,
                                 log_file,
                                 NULL);
+        free(log_file);
 
         fd = open(log_path, O_RDWR|O_CREAT|O_TRUNC, 0640);
         if (fd < 0) {
--- a/orte/util/context_fns.c
+++ b/orte/util/context_fns.c
@@ -55,10 +55,12 @@
 {
     bool good = true;
     const char *tmp;
+#if 0 /* 'hostname' looks unused... */
     char hostname[MAXHOSTNAMELEN];
     
     /* Use hostname in a few messages below */
     gethostname(hostname, sizeof(hostname));
+#endif
     
     /* If we want to chdir and the chdir fails (for any reason -- such
        as if the dir doesn't exist, it isn't a dir, we don't have
